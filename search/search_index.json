{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CRISGI","text":"<p>Welcome to the official documentation of Charting CRItical tranSient Gene Interactions in Disease Progression from Multi-modal Transcriptomics (CRISGI)!</p>"},{"location":"#overview","title":"\ud83d\uddfa\ufe0f Overview","text":"<p>Critical transitions (CTs) in gene regulatory networks (GRNs) drive pivotal shifts in disease progression. While CT theory holds great promise for early disease detection, existing computational frameworks face major limitations. They rely on unsupervised ranking of CT signals at individual gene or gene-module level, apply unranked gene set enrichment analyses, and depend on manual inspection of signal trends to infer CT presence and onset within a single cohort. Additionally, multimodal transcriptomic data remain underutilized. These approaches limit mechanistic resolution and hinder clinical translation.</p> <p>We present CRISGI, a novel CT framework designed to overcome these challenges. CRISGI enables phenotype-specific CT gene-gene interaction modeling, CT-rank enrichment analyses, automated CT presence and onset prediction, and supports bulk, single-cell, and spatial transcriptomic (ST) data.</p> <p>In viral infections, CRISGI identified 128 CT interactions (128-TER) predictive of symptom status and onset, validated across six external bulk RNA-seq cohorts and COVID-19 scRNA-seq datasets. It further revealed cell-type-specific early immune exhaustion signals associated with severe COVID-19 outcomes.</p> <p>In cancer, CRISGI uncovered stage-specific CT interactions linked to survival across five TCGA bulk RNA-seq data, highlighted FoxO/p53 signaling in scRNA-seq colorectal cancer progression, and identified LUM-driven invasive transitions in ST breast tumors.</p> <p>Together, CRISGI bridges mechanistic insight and translational potential, enabling early and context-specific detection of disease transitions.</p>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>Want to start using it immediately? Check out the following sections:</p>"},{"location":"#installation","title":"\ud83d\udce5 Installation","text":"<p>CRISGI is a Python package that can be installed via pip. You can install it from PyPI or from the source.</p> <p>Details on how to install CRISGI can be found in the Installation section.</p>"},{"location":"#usage","title":"\ud83d\udd27 Usage","text":"<p>CRISGI is designed to be user-friendly and easy to use. The package provides a set of functions that can be used to perform various tasks related to critical transitions in gene interactions.</p>"},{"location":"#tutorials","title":"\ud83d\udcd6 Tutorials","text":"<p>Moreover, you can find some tutorials in the Tutorial section. These tutorials will guide you through the process of using CRISGI for your own data analysis.</p>"},{"location":"#api-reference","title":"\ud83d\udcda API Reference","text":"<p>For more detailed information, please refer to the API Reference.</p>"},{"location":"#citation","title":"\ud83d\udcd1 Citation","text":"<p>If you use CRISGI in your research, please cite the following paper:</p> <p>APA format:</p> <pre><code>Lyu, C., Jiang, A., Ng, K. H., Liu, X., &amp; Chen, L. (2025). Predicting Early Transitions in Respiratory Virus Infections via Critical Transient Gene Interactions. bioRxiv. https://doi.org/10.1101/2025.04.18.649619\n</code></pre> <p>BibTeX format:</p> <pre><code>@article{crisgi,\n  title={Predicting Early Transitions in Respiratory Virus Infections via Critical Transient Gene Interactions},\n  author={Lyu, Chengshang and Jiang, Anna and Ng, Ka Ho and Liu, Xiaoyu and Chen, Lingxi},\n  journal={bioRxiv},\n  year={2025},\n  doi={10.1101/2025.04.18.649619},\n  publisher={Cold Spring Harbor Laboratory}\n}\n</code></pre>"},{"location":"api_reference/","title":"\ud83d\udcda API Reference","text":"<ul> <li>calculate_entropy</li> <li>check_common_diff</li> <li>cohort_level_top_n_ORA</li> <li>crisgi_init</li> <li>crisgitime_init</li> <li>detection_startpoint</li> <li>find_interaction_module</li> <li>get_DER</li> <li>init</li> <li>init_edata</li> <li>load_crisgi</li> <li>obs_level_CT_rank</li> <li>pheno_level_CT_rank</li> <li>pheno_level_accumulated_top_n_ORA</li> <li>pl.interaction_score_line</li> <li>pl.pheno_level_accumulated_top_n_ORA</li> <li>save</li> <li>survival_analysis</li> <li>test_DER</li> <li>test_TER</li> <li>test_val_trend_entropy</li> <li>train_predict</li> </ul>"},{"location":"installation/","title":"\ud83d\udce5 Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>pip (Python package installer)</li> <li>git (if installing from source)</li> <li>conda (optional, for creating a virtual environment)</li> </ul>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<ul> <li>numpy</li> <li>pandas</li> <li>torch</li> <li>pillow</li> <li>scikit-learn</li> <li>scanpy</li> <li>anndata</li> <li>pickle</li> <li>matplotlib</li> <li>seaborn</li> <li>pyvis</li> <li>pyseat</li> <li>gesapy</li> <li>scikit-survival</li> <li>pymannkendall</li> <li>multiprocessing</li> </ul>"},{"location":"installation/#installation-steps","title":"Installation Steps","text":"<pre><code># Installation (From PyPI)\npip install CRISGI\n\n# Installation (From Source)\npip install git+https://github.com/compbioclub/CRISGI.git@main\n</code></pre>"},{"location":"tutorial/","title":"\ud83d\udcd6 Tutorial","text":"<p>There is a tutorial available in this section.</p>"},{"location":"tutorial/#1-simple-example-bulk-rna-seq","title":"1. Simple Example (bulk RNA-seq)","text":"<p>The first one is a simple example of how to use CRISGI with influenza A bulk RNA-seq dataset.</p>"},{"location":"api/calculate_entropy/","title":"calculate_entropy","text":""},{"location":"api/calculate_entropy/#function","title":"Function","text":"<pre><code>crisgi_obj.calculate_entropy(\n    ref_obs, \n    test_obss, \n    groupby, \n    ref_time, \n    layer='log1p'\n)\n</code></pre> <p>Calculates the entropy changes of gene-gene interactions between a reference group and one or more test populations within a single-cell dataset. This function initializes the entropy data structure, computes entropy for the reference and test populations, and stores the results for downstream analysis. The entropy calculation can be performed using different interaction methods, including a product-based approach if specified.</p>"},{"location":"api/calculate_entropy/#parameters","title":"Parameters","text":"Name Type Description ref_obs list or array List of observation (cell) identifiers for the reference group. test_obss list of lists List of test population, each a list of observation (cell) identifiers. groupby str The column name in <code>obs</code> used to group observations (e.g., experimental condition, batch). ref_time str or int Reference time point or label, used for naming output layers. layer str, optional Name of the data layer in AnnData to use for calculations (default: <code>'log1p'</code>)."},{"location":"api/calculate_entropy/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/calculate_entropy/#returns","title":"Returns","text":"<p>This function does not return a value. Instead, it updates the <code>edata</code> attribute of the CRISGI object with entropy results and related metadata for each test population compared to the reference group.</p>"},{"location":"api/calculate_entropy/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>self.ref_time</code>: Stores the reference time or label used in the calculation.</li> <li><code>self.edata</code>: An AnnData object containing entropy results and metadata for each test population.</li> <li><code>self.adata_dict</code> (if applicable): Dictionary mapping group identifiers to AnnData objects with entropy calculations.</li> <li><code>self.test_obss</code>: Stores the list of test populations used in the calculation.</li> <li><code>self.ref_obs</code>: Stores the reference group used in the calculation.</li> </ul>"},{"location":"api/calculate_entropy/#example","title":"Example","text":"<pre><code>from crisgi import CRISGI\n\n# Assume adata is an AnnData object with required structure and data\ncrisgi = CRISGI(adata)\n\n# Define reference and test populations\nref_obs = adata.obs[adata.obs['condition'] == 'control'].index.tolist()\ntest_obss = [\n    adata.obs[adata.obs['condition'] == 'treatment1'].index.tolist(),\n    adata.obs[adata.obs['condition'] == 'treatment2'].index.tolist()\n]\n\n# Calculate entropy changes between reference and test populations\ncrisgi.calculate_entropy(\n    ref_obs=ref_obs,\n    test_obss=test_obss,\n    groupby='condition',\n    ref_time='day0',\n    layer='log1p'\n)\n\n# Access the results\nentropy_results = crisgi.edata\nprint(entropy_results)\n</code></pre>"},{"location":"api/check_common_diff/","title":"check_common_diff","text":""},{"location":"api/check_common_diff/#function","title":"Function","text":"<pre><code>crisgi_obj.check_common_diff(\n    top_n,\n    target_group,\n    layer=\"log1p\",\n    method=\"prod\",\n    test_type=\"TER\",\n    interactions=None,\n    unit_header=\"subject\",\n    out_dir=None,\n)\n</code></pre> <p>Identifies and analyzes the overlap between the top N differential features (e.g., genes or interactions) and a reference set within the dataset. This function is useful for evaluating the consistency of differential features across groups or conditions in the CRISGI analysis workflow.</p>"},{"location":"api/check_common_diff/#parameters","title":"Parameters","text":"Name Type Description <code>top_n</code> <code>int</code> Number of top features to consider for overlap analysis. <code>target_group</code> <code>str</code> The group or condition by which to stratify the analysis. <code>layer</code> <code>str</code> Data layer to use for entropy calculation (default: <code>'log1p'</code>). <code>method</code> <code>str</code> Method for entropy calculation (default: <code>'prod'</code>). <code>test_type</code> <code>str</code> Statistical test type to use (default: <code>'TER'</code>). <code>interactions</code> <code>list</code> or <code>None</code> List of features to compare for overlap. If <code>None</code>, uses default from <code>edata.uns</code>. <code>unit_header</code> <code>str</code> Header indicating the unit of analysis (default: <code>'subject'</code>). <code>out_dir</code> <code>str</code> or <code>None</code> Output directory to save results. If <code>None</code>, saves to current directory."},{"location":"api/check_common_diff/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/check_common_diff/#returns","title":"Returns","text":"<p>This function does not return a value. It updates the <code>obs</code> attribute of the <code>edata</code> object with two new columns: - <code>top_{top_n}_overlap</code>: Number of overlapping features for each observation. - <code>top_{top_n}_overlap_ratio</code>: Ratio of overlapping features to <code>top_n</code>.</p> <p>It also saves a CSV file with these statistics to the specified output directory.</p>"},{"location":"api/check_common_diff/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>edata.obs['top_{top_n}_overlap']</code></li> <li><code>edata.obs['top_{top_n}_overlap_ratio'}</code></li> </ul>"},{"location":"api/check_common_diff/#example","title":"Example","text":"<pre><code># Assume crisgi is an instance of the CRISGI class\ncrisgi.check_common_diff(\n    top_n=20,\n    target_group='cell_type',\n    layer='log1p',\n    method='prod',\n    test_type='TER',\n    interactions=['GeneA', 'GeneB', 'GeneC'],\n    unit_header='subject',\n    out_dir='results'\n)\n\n# After running, check the overlap statistics:\nimport pandas as pd\noverlap_stats = pd.read_csv('./results/top_20_overlap.csv')\nprint(overlap_stats.head())\n</code></pre> <p>This example computes the overlap of the top 20 differential features per cell type, using the specified interactions, and saves the results in the <code>results</code> directory.</p>"},{"location":"api/cohort_level_top_n_ORA/","title":"cohort_level_top_n_ORA","text":""},{"location":"api/cohort_level_top_n_ORA/#function","title":"Function","text":"<pre><code>crisgi_obj.cohort_level_top_n_ORA(\n    n_top_interactions=None,\n    method='prod',\n    gene_sets=[\n        'KEGG_2021_Human',\n        'GO_Molecular_Function_2023',\n        'GO_Cellular_Component_2023',\n        'GO_Biological_Process_2023',\n        'MSigDB_Hallmark_2020'\n    ],\n    background=None,\n    organism='human',\n    plot=True,\n)\n</code></pre> <p>Performs cohort-level over-representation analysis (ORA) for the top N interactions in the dataset, across multiple gene sets. The function iteratively analyzes the enrichment of gene sets for increasing numbers of top interactions, saves the results to a CSV file, and stores the enrichment results in the object's attributes.</p>"},{"location":"api/cohort_level_top_n_ORA/#parameters","title":"Parameters","text":"Name Type Description n_top_interactions int, optional Number of top interactions to consider. If None, uses all available interactions. method str, optional Method used for scoring interactions (e.g., <code>'prod'</code>). Default is <code>'prod'</code>. gene_sets list of str, optional List of gene set names to use for enrichment analysis. Default includes several common sets. background list or None, optional Background gene set for enrichment. If None, uses all genes in the dataset. organism str, optional Organism name (e.g., <code>'human'</code>). Default is <code>'human'</code>. plot bool, optional Whether to generate plots for the enrichment results. Default is <code>True</code>."},{"location":"api/cohort_level_top_n_ORA/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/cohort_level_top_n_ORA/#returns","title":"Returns","text":"<p>This function does not return a value. It saves the enrichment results to a CSV file and updates the object's attributes with the results.</p>"},{"location":"api/cohort_level_top_n_ORA/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>self.edata.uns[f'{method}_cohort_enrich_res']</code>: Dictionary mapping top N values to enrichment results.</li> <li><code>self.edata.uns[f'{method}_cohort_enrich_df']</code>: DataFrame containing concatenated enrichment results for all top N values.</li> </ul>"},{"location":"api/cohort_level_top_n_ORA/#example","title":"Example","text":"<pre><code># Assuming `obj` is an instance of the class containing this method\n\nobj.cohort_level_top_n_ORA(\n    n_top_interactions=100,\n    method='prod',\n    gene_sets=['KEGG_2021_Human', 'GO_Biological_Process_2023'],\n    organism='human',\n    plot=True\n)\n\n# After execution, enrichment results are saved to a CSV file in obj.out_dir,\n# and results are accessible via:\n# obj.edata.uns['prod_cohort_enrich_res']\n# obj.edata.uns['prod_cohort_enrich_df']\n</code></pre>"},{"location":"api/crisgi_init/","title":"CRISGI Class Initialization","text":""},{"location":"api/crisgi_init/#function","title":"Function","text":"<p>The <code>CRISGI</code> class initializes and preprocesses gene expression data for downstream analysis, including background network construction and feature selection. It provides methods for data preprocessing, background network loading, and supports various interaction inference methods.</p>"},{"location":"api/crisgi_init/#parameters","title":"Parameters","text":"Name Type Description <code>adata</code> AnnData Annotated data matrix (cells \u00d7 genes) to be analyzed. <code>bg_net</code> array or None Optional. Precomputed background network matrix. <code>bg_net_score_cutoff</code> int Score threshold for filtering background network edges. Default is <code>850</code>. <code>genes</code> list or None Optional. List of gene names to include in the analysis. <code>n_hvg</code> int or None Number of highly variable genes to select. Default is <code>5000</code>. <code>n_pcs</code> int Number of principal components for dimensionality reduction. Default is <code>30</code>. <code>interactions</code> array or None Optional. Predefined gene-gene interactions to use for background network construction. <code>n_threads</code> int Number of threads to use for computation. Default is <code>5</code>. <code>interaction_methods</code> list List of methods for inferring gene interactions. Default: <code>['prod']</code>. <code>organism</code> str Organism name (e.g., <code>'human'</code>). Default is <code>'human'</code>. <code>class_type</code> str Type of classification task (e.g., <code>'time'</code>). Default is <code>'time'</code>. <code>dataset</code> str Dataset identifier. Default is <code>'test'</code>. <code>out_dir</code> str Output directory for results. Default is <code>'./out'</code>."},{"location":"api/crisgi_init/#return-type","title":"Return Type","text":"<p><code>CRISGI</code> object</p>"},{"location":"api/crisgi_init/#returns","title":"Returns","text":"<p>Initializes a <code>CRISGI</code> object with preprocessed data and background network ready for downstream analysis.</p>"},{"location":"api/crisgi_init/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>adata</code>: Preprocessed AnnData object.</li> <li><code>interaction_methods</code>: List of interaction inference methods.</li> <li><code>organism</code>: Organism name.</li> <li><code>n_threads</code>: Number of computation threads.</li> <li><code>dataset</code>: Dataset identifier.</li> <li><code>class_type</code>: Classification type.</li> <li><code>out_dir</code>: Output directory path.</li> <li><code>bg_net_score_cutoff</code>: Background network score cutoff.</li> </ul>"},{"location":"api/crisgi_init/#example","title":"Example","text":"<pre><code>import anndata as ad\nfrom crisgi import CRISGI\n\n# Load your single-cell data into an AnnData object\nadata = ad.read_h5ad('example_data.h5ad')\n\n# Initialize CRISGI with default parameters\ncrisgi = CRISGI(\n    adata=adata,\n    n_hvg=3000,\n    n_pcs=20,\n    organism='human',\n    class_type='time',\n    dataset='my_dataset',\n    out_dir='./crisgi_output'\n)\n\n# The object is now ready for further analysis\nprint(crisgi.adata)\nprint(crisgi.interaction_methods)\n</code></pre>"},{"location":"api/crisgitime_init/","title":"CRISGITime Class Initialization","text":""},{"location":"api/crisgitime_init/#function","title":"Function","text":"<p>The <code>CRISGITime</code> class extends the <code>CRISGI</code> base class to provide time-based modeling for gene expression data. It supports various neural network architectures (3L-CNN, 1L-CNN (simple CNN), logistic regression) for downstream analysis, and manages model selection, initialization, and device assignment.</p>"},{"location":"api/crisgitime_init/#parameters","title":"Parameters","text":"Name Type Description <code>adata</code> AnnData Annotated data matrix (typically single-cell gene expression data). <code>device</code> str Device to run the model on (<code>'cpu'</code> or <code>'cuda'</code>). Default is <code>'cpu'</code>. <code>model_type</code> str Type of model to use (<code>'cnn'</code>, <code>'simple_cnn'</code>, or <code>'logistic'</code>). Default is <code>'cnn'</code>. <code>ae_path</code> str Path to a pre-trained autoencoder model (optional, used for CNN-based models). <code>mlp_path</code> str Path to a pre-trained MLP model (optional, used for CNN-based models). <code>model_path</code> str Path to a pre-trained logistic regression model (optional, used for logistic model). <code>**kwargs</code> dict Additional keyword arguments passed to the base <code>CRISGI</code> class."},{"location":"api/crisgitime_init/#return-type","title":"Return type","text":"<p><code>CRISGITime</code> object</p>"},{"location":"api/crisgitime_init/#returns","title":"Returns","text":"<p>An instance of the <code>CRISGITime</code> class, initialized with the specified data, model type, and device. The model is ready for downstream analysis.</p>"},{"location":"api/crisgitime_init/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>adata</code>: Processed AnnData object.</li> <li><code>device</code>: Device used for computation.</li> <li><code>model_type</code>: Type of model selected.</li> <li><code>model</code>: Instantiated model object (CNNModel, SimpleCNNModel, or LogisticModel).</li> <li><code>out_dir</code>: Output directory for results.</li> <li>Other attributes inherited from <code>CRISGI</code> (e.g., <code>interaction_methods</code>, <code>organism</code>, <code>n_threads</code>, etc.).</li> </ul>"},{"location":"api/crisgitime_init/#example","title":"Example","text":"<pre><code>import anndata as ad\nfrom crisgitime import CRISGITime\n\n# Load your single-cell data\nadata = ad.read_h5ad('your_data.h5ad')\n\n# Initialize CRISGITime with a CNN model on CPU\ncrisgi_time = CRISGITime(\n    adata=adata,\n    device='cpu',\n    model_type='cnn',\n    ae_path='path/to/autoencoder.pth',\n    mlp_path='path/to/mlp.pth',\n    out_dir='./results'\n)\n\n# The model is now ready for downstream analysis\nprint(crisgi_time.model_type)  # Output: cnn\nprint(crisgi_time.device)      # Output: cpu\n</code></pre>"},{"location":"api/detect_startpoint/","title":"detect_startpoint","text":""},{"location":"api/detect_startpoint/#function","title":"Function","text":"<pre><code>crisgi_obj.detect_startpoint(symptom_types = [\"Symptomatic\"])\n</code></pre> <p>Detects the start point (CT_time) for samples with specified symptom types and updates the <code>CT_time</code> column in <code>edata.obs</code>. This method filters samples based on the provided symptom types, processes each subject's data, applies a start point detection algorithm, and stores the predicted start time for each subject.</p>"},{"location":"api/detect_startpoint/#parameters","title":"Parameters","text":"Name Type Description symptom_types list of str A list of symptom types to filter samples by. Should match values in <code>edata.obs['symptom']</code>. Default is <code>[\"Symptomatic\"]</code>."},{"location":"api/detect_startpoint/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/detect_startpoint/#returns","title":"Returns","text":"<p>This function does not return a value. It updates the <code>CT_time</code> attribute in the <code>edata.obs</code> DataFrame for each subject matching the specified symptom types.</p>"},{"location":"api/detect_startpoint/#attributes-set","title":"Attributes Set","text":"<ul> <li>edata.obs['CT_time']: The predicted start time (CT_time) for each subject with the specified symptom types.</li> </ul>"},{"location":"api/detect_startpoint/#example","title":"Example","text":"<pre><code># Assume CRISGI is already imported and instantiated as crisgi\n# and crisgi.edata is properly initialized\n\n# Detect start points for symptomatic subjects (default)\ncrisgi.detect_startpoint()\n\n# Detect start points for both symptomatic and asymptomatic subjects\ncrisgi.detect_startpoint(symptom_types=[\"Symptomatic\", \"Asymptomatic\"])\n\n# After running, check the predicted CT_time for each subject\nprint(crisgi.edata.obs[['subject', 'CT_time']].drop_duplicates())\n</code></pre>"},{"location":"api/find_interaction_module/","title":"find_interaction_module","text":""},{"location":"api/find_interaction_module/#function","title":"Function","text":"<pre><code>find_interaction_module(\n    target_group,\n    layer='log1p',\n    method='prod',\n    test_type='TER',\n    interactions=None,\n    unit_header='subject',\n    out_dir=None,\n    label_df=None,\n    n_neighbors=10,\n    strategy='bottom_up'\n)\n</code></pre> <p>Identifies and clusters gene interaction modules within a specified group using a community detection algorithm. The function computes interaction matrices, applies clustering, and outputs results including interaction matrices, community/module assignments, and hierarchical relationships.</p>"},{"location":"api/find_interaction_module/#parameters","title":"Parameters","text":"Name Type Description target_group str The group label to analyze within the data. layer str, optional The data layer to use for calculations (default: <code>'log1p'</code>). method str, optional Method for interaction calculation (default: <code>'prod'</code>). test_type str, optional Type of statistical test to use (default: <code>'TER'</code>). interactions list, optional List of interaction names to analyze. If <code>None</code>, uses all available interactions. unit_header str, optional Column in <code>obs</code> to use as the unit identifier (default: <code>'subject'</code>). out_dir str, optional Output directory for saving results. If <code>None</code>, uses the class's <code>out_dir</code> attribute. label_df pd.DataFrame, optional DataFrame for custom labels. If <code>None</code>, labels are generated automatically. n_neighbors int, optional Number of neighbors for clustering (default: <code>10</code>). strategy str, optional Clustering strategy to use (default: <code>'bottom_up'</code>)."},{"location":"api/find_interaction_module/#return-type","title":"Return type","text":"<p><code>pandas.DataFrame</code></p>"},{"location":"api/find_interaction_module/#returns","title":"Returns","text":"<p>A DataFrame indexed by interaction names, containing the assigned community and module for each interaction.</p>"},{"location":"api/find_interaction_module/#attributes-set","title":"Attributes Set","text":"<ul> <li>Saves the following files to <code>out_dir</code>:</li> <li>Interaction matrix CSV</li> <li>Interaction community/module CSV</li> <li>Interaction hierarchy in Newick format</li> </ul>"},{"location":"api/find_interaction_module/#example","title":"Example","text":"<pre><code># Assume `crisgi` is an instance of CRISGI with loaded data\n\nresult_df = crisgi.find_interaction_module(\n    target_group='GroupA',\n    layer='log1p',\n    method='prod',\n    test_type='TER',\n    interactions=None,  # Use all available interactions\n    unit_header='subject',\n    out_dir='./results',\n    n_neighbors=15,\n    strategy='bottom_up'\n)\n\n# The result_df contains community and module assignments for each interaction.\n# Output files are saved in './results' directory.\n</code></pre>"},{"location":"api/get_DER/","title":"get_DER","text":""},{"location":"api/get_DER/#function","title":"Function","text":"<pre><code>crisgi_obj.get_DER(\n    target_group=None,\n    n_top_interactions=None,\n    method='prod',\n    p_adjust=True,\n    p_cutoff=0.05,\n    fc_cutoff=1,\n    sortby='scores'.\n)\n</code></pre> <p>Identifies Differentially Expressed Reactions (DER) between groups in the dataset. This function compares all pairs of groups, computes statistics for each, and identifies interactions that are significantly differentially expressed according to specified thresholds. Results are saved to CSV files and stored in the <code>edata.uns</code> attribute for downstream analysis.</p>"},{"location":"api/get_DER/#parameters","title":"Parameters","text":"Name Type Description <code>target_group</code> str or None The group to compare against all others. If <code>None</code>, all groups are compared. <code>n_top_interactions</code> int or None Number of top interactions to return per group. If <code>None</code>, returns all. <code>method</code> str Method used for ranking genes (e.g., <code>'prod'</code>). <code>p_adjust</code> bool Whether to use adjusted p-values (<code>True</code>) or raw p-values (<code>False</code>). <code>p_cutoff</code> float P-value cutoff for significance. <code>fc_cutoff</code> float Log fold change cutoff for significance. <code>sortby</code> str Column to sort results by (<code>'scores'</code>, <code>'logfoldchanges'</code>, or other valid column names)."},{"location":"api/get_DER/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/get_DER/#returns","title":"Returns","text":"<p>This function does not return a value. It saves the results to CSV files and updates the <code>edata.uns</code> attribute with DER interactions and their corresponding dataframes for each group.</p>"},{"location":"api/get_DER/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>edata.uns[f'{method}_{self.groupby}_{target_group}_DER']</code>:   List of DER interaction names for each target group.</li> <li><code>edata.uns[f'{method}_{self.groupby}_{target_group}_DER_df']</code>:   DataFrame containing DER statistics for each target group.</li> </ul>"},{"location":"api/get_DER/#example","title":"Example","text":"<pre><code># Assume `obj` is an instance of the class containing `get_DER`\n# Identify DERs for all groups using default parameters\nobj.get_DER()\n\n# Identify DERs for a specific group with custom thresholds\nobj.get_DER(\n    target_group='GroupA',\n    n_top_interactions=20,\n    method='prod',\n    p_adjust=True,\n    p_cutoff=0.01,\n    fc_cutoff=1.5,\n    sortby='logfoldchanges'\n)\n\n# After running, results are saved to CSV files in `obj.out_dir`\n# and DER lists/dataframes are available in `obj.edata.uns`\n</code></pre>"},{"location":"api/init/","title":"Initialization","text":""},{"location":"api/init/#crisgiinit","title":"CRISGI.init","text":""},{"location":"api/init/#function","title":"Function","text":"<pre><code>__init__(\n    adata,\n    bg_net=None,\n    bg_net_score_cutoff=850,\n    genes=None,\n    n_hvg=5000,\n    n_pcs=30,\n    interactions=None,\n    n_threads=5,\n    interaction_methods=[\"prod\"],\n    organism=\"human\",\n    class_type=\"time\",\n    dataset=\"test\",\n    out_dir=\"./out\",\n)\n</code></pre> <p>Initializes a CRISGI object for single-cell gene interaction analysis. Sets up the AnnData object, prepares the background network, and configures preprocessing and output directories.</p>"},{"location":"api/init/#parameters","title":"Parameters","text":"Name Type Description adata AnnData The annotated data matrix (cells x genes) to be analyzed. bg_net Optional Precomputed background network (default: None). bg_net_score_cutoff int Score cutoff for background network edges (default: 850). genes list or None List of gene names to include (default: None, uses highly variable genes if available). n_hvg int or None Number of highly variable genes to select (default: 5000). n_pcs int Number of principal components for PCA (default: 30). interactions Optional Predefined gene interactions (default: None). n_threads int Number of threads to use for computation (default: 5). interaction_methods list Methods for interaction inference (default: [\"prod\"]). organism str Organism name (default: 'human'). class_type str Type of analysis class (default: 'time'). dataset str Dataset identifier (default: 'test'). out_dir str Output directory for results (default: './out')."},{"location":"api/init/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/init/#returns","title":"Returns","text":"<p>Initializes the CRISGI object and prepares it for downstream analysis.</p>"},{"location":"api/init/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>adata</code>: Processed AnnData object.</li> <li><code>interaction_methods</code>: List of interaction inference methods.</li> <li><code>organism</code>: Organism name.</li> <li><code>n_threads</code>: Number of threads for computation.</li> <li><code>dataset</code>: Dataset identifier.</li> <li><code>class_type</code>: Type of analysis class.</li> <li><code>out_dir</code>: Output directory path.</li> <li><code>bg_net_score_cutoff</code>: Score cutoff for background network.</li> <li><code>adata.varm['bg_net']</code>: Background network matrix.</li> </ul>"},{"location":"api/init/#example","title":"Example","text":"<pre><code>import scanpy as sc\nfrom crisgi import CRISGI\n\nadata = sc.read_h5ad('example_data.h5ad')\ncrisgi = CRISGI(\n    adata,\n    interaction_methods=[\"prod\"],\n    n_hvg=3000,\n    n_pcs=20,\n    organism='human',\n    out_dir='./crisgi_results'\n)\n</code></pre>"},{"location":"api/init/#crisgitimeinit","title":"CRISGITime.init","text":""},{"location":"api/init/#function_1","title":"Function","text":"<pre><code>__init__(\n    self,\n    adata,\n    device=\"cpu\",\n    model_type=\"cnn\",\n    ae_path=None,\n    mlp_path=None,\n    model_path=None,\n    **kwargs\n)\n</code></pre> <p>Initializes a CRISGITime object for time-series or temporal single-cell gene interaction analysis. Inherits from CRISGI and adds model selection and device configuration.</p>"},{"location":"api/init/#parameters_1","title":"Parameters","text":"Name Type Description adata AnnData The annotated data matrix (cells x genes) to be analyzed. device str Device to use for computation (<code>'cpu'</code> or <code>'cuda'</code>, default: <code>'cpu'</code>). model_type str Model type to use (<code>'cnn'</code>, <code>'simple_cnn'</code>, <code>'logistic'</code>, default: <code>'cnn'</code>). ae_path str/None Path to autoencoder model weights (optional). mlp_path str/None Path to MLP model weights (optional). model_path str/None Path to logistic model weights (optional). **kwargs dict Additional keyword arguments passed to CRISGI.init."},{"location":"api/init/#return-type_1","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/init/#returns_1","title":"Returns","text":"<p>Initializes the CRISGITime object and sets up the selected model for downstream analysis.</p>"},{"location":"api/init/#attributes-set_1","title":"Attributes Set","text":"<ul> <li>All attributes from <code>CRISGI</code>.</li> <li><code>device</code>: Computation device.</li> <li><code>model_type</code>: Selected model type.</li> <li><code>model</code>: Instantiated model object.</li> </ul>"},{"location":"api/init/#example_1","title":"Example","text":"<pre><code>import scanpy as sc\nfrom crisgi import CRISGITime\n\nadata = sc.read_h5ad('example_data.h5ad')\ncrisgi_time = CRISGITime(\n    adata,\n    interaction_methods=[\"prod\"],\n    device='cuda',\n    model_type='cnn',\n    out_dir='./crisgi_time_results'\n)\n</code></pre>"},{"location":"api/init_edata/","title":"init_edata","text":""},{"location":"api/init_edata/#function","title":"Function","text":"<pre><code>crisgi_obj.init_edata(test_obss, headers)\n</code></pre> <p>Initializes the <code>edata</code> attribute for the object by extracting and organizing observation and interaction data from the underlying AnnData structure. This function prepares a new AnnData object (<code>edata</code>) containing selected observations and gene-gene interaction information, and sets it as an attribute for downstream analysis.</p>"},{"location":"api/init_edata/#parameters","title":"Parameters","text":"Name Type Description test_obss list of list A list where each element is a list of observation indices or labels to include (test populations). headers list of str List of column names from the observation metadata to retain in <code>edata.obs</code>."},{"location":"api/init_edata/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/init_edata/#returns","title":"Returns","text":"<p>This function does not return a value. It sets the <code>edata</code> attribute on the object with a new AnnData instance containing the selected observations and interaction data.</p>"},{"location":"api/init_edata/#attributes-set","title":"Attributes Set","text":"<ul> <li>self.edata: <code>AnnData</code>   The newly created AnnData object containing the selected observations and gene-gene interaction information.</li> </ul>"},{"location":"api/init_edata/#example","title":"Example","text":"<pre><code># Suppose `crisgi_obj` is an instance of the class containing `init_edata`\n# test_obss is a list of lists of observation indices or labels (test populations)\ntest_obss = [\n        ['cell_1', 'cell_2'],\n        ['cell_3', 'cell_4']\n]\n# headers are the columns to keep from the observation metadata\nheaders = ['test', 'group']\n\ncrisgi_obj.init_edata(test_obss, headers)\n\n# After calling, crisgi_obj.edata will be available for further analysis:\nprint(crisgi_obj.edata.shape)  # (number of observations, number of interactions)\nprint(crisgi_obj.edata.obs.head())  # Shows the selected observation metadata\nprint(crisgi_obj.edata.var.head())  # Shows gene interaction information\n</code></pre>"},{"location":"api/load_crisgi/","title":"load_crisgi","text":""},{"location":"api/load_crisgi/#function","title":"Function","text":"<pre><code>load_crisgi(pk_fn)\n</code></pre> <p>Loads a CRISGI object from a specified pickle file and prints a confirmation message upon successful loading.</p>"},{"location":"api/load_crisgi/#parameters","title":"Parameters","text":"Name Type Description pk_fn str Path to the pickle file containing the CRISGI object."},{"location":"api/load_crisgi/#return-type","title":"Return type","text":"<p><code>object</code></p>"},{"location":"api/load_crisgi/#returns","title":"Returns","text":"<p>The CRISGI object that was loaded from the specified pickle file.</p>"},{"location":"api/load_crisgi/#attributes-set","title":"Attributes Set","text":"<p>This function does not set any attributes on the returned object or elsewhere.</p>"},{"location":"api/load_crisgi/#example","title":"Example","text":"<pre><code>import pickle\n\ndef print_msg(msg):\n    print(msg)\n\ndef load_crisgi(pk_fn):\n    crisgi_obj = pickle.load(open(pk_fn, 'rb'))\n    print_msg(f'[Input] CRISGI object stored at {pk_fn} has been loaded.')\n    return crisgi_obj\n\n# Example usage:\n# Assume you have previously saved a CRISGI object to 'crisgi_obj.pkl'\n# To load it:\n\ncrisgi = load_crisgi('crisgi_obj.pkl')\n# Output: [Input] CRISGI object stored at crisgi_obj.pkl has been loaded.\n</code></pre>"},{"location":"api/network_analysis/","title":"network_analysis","text":""},{"location":"api/network_analysis/#function","title":"Function","text":"<pre><code>crisgi_obj.network_analysis(\n    target_group,\n    layer=\"log1p\",\n    method=\"prod\",\n    test_type=\"TER\",\n    interactions=None,\n    unit_header=\"subject\",\n    out_dir=None,\n    n_neighbors=10,\n    strategy=\"bottom_up\",\n)\n</code></pre> <p>Performs network analysis on the dataset using specified parameters and interaction sets. This method extracts and analyzes interaction features from the data, supporting various strategies and test types for flexible network exploration.</p>"},{"location":"api/network_analysis/#parameters","title":"Parameters","text":"Name Type Description target_group str The group identifier for which the network analysis is performed. layer str, optional The data layer to use for analysis (default: <code>'log1p'</code>). method str, optional The method for interaction calculation (default: <code>'prod'</code>). test_type str, optional The statistical test type to use (default: <code>'TER'</code>). interactions list, optional List of interaction features to include; if <code>None</code>, uses default from <code>edata.uns</code>. unit_header str, optional The header indicating the unit of analysis (default: <code>'subject'</code>). out_dir str, optional Output directory for results; if <code>None</code>, results are not saved to disk. n_neighbors int, optional Number of neighbors to consider in the analysis (default: <code>10</code>). strategy str, optional Strategy for network construction (default: <code>'bottom_up'</code>)."},{"location":"api/network_analysis/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/network_analysis/#returns","title":"Returns","text":"<p>This function does not return a value. It performs network analysis and may print or save intermediate results depending on the parameters.</p>"},{"location":"api/network_analysis/#attributes-set","title":"Attributes Set","text":"<ul> <li>May access or update <code>self.edata</code>, <code>self.adata</code>, and related attributes.</li> <li>Uses or sets keys in <code>edata.uns</code>.</li> </ul>"},{"location":"api/network_analysis/#example","title":"Example","text":"<pre><code># Assume `crisgi` is an instance of the CRISGI class\n\n# Perform network analysis for group 'A' with default settings\ncrisgi.network_analysis(target_group='A')\n\n# Perform network analysis with custom interactions and output directory\ncustom_interactions = ['gene1', 'gene2', 'gene3']\ncrisgi.network_analysis(\n    target_group='B',\n    interactions=custom_interactions,\n    out_dir='/path/to/output',\n    n_neighbors=15,\n    strategy='top_down'\n)\n</code></pre>"},{"location":"api/obs_level_CT_rank/","title":"obs_level_CT_rank","text":""},{"location":"api/obs_level_CT_rank/#function","title":"Function","text":"<pre><code>crisgi_obj.obs_level_CT_rank(gene_sets, prefix='test', min_size=5)\n</code></pre> <p>Performs observation-level cell type (CT) ranking using gene set variation analysis (GSVA) on the provided gene sets. This method is designed as a member function of the <code>crisgi_obj</code> class. It computes enrichment scores for each observation (cell/sample), ranks them, and saves the results to a CSV file. If group information is available, it annotates the results accordingly.</p>"},{"location":"api/obs_level_CT_rank/#parameters","title":"Parameters","text":"Name Type Description gene_sets object Dictionary or compatible object containing gene sets for GSVA analysis. prefix str Prefix for output directory and files. Default is <code>'test'</code>. min_size int Minimum number of genes required in each gene set. Default is <code>5</code>."},{"location":"api/obs_level_CT_rank/#return-type","title":"Return type","text":"<p><code>pandas.DataFrame</code></p>"},{"location":"api/obs_level_CT_rank/#returns","title":"Returns","text":"<p>A DataFrame with GSVA enrichment scores for each observation, optionally annotated with group information and sorted by enrichment score (ES). The results are also exported as a CSV file in the specified output directory.</p>"},{"location":"api/obs_level_CT_rank/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>self.gp_es</code>: Stores the GSVA result object for downstream analysis.</li> </ul>"},{"location":"api/obs_level_CT_rank/#example","title":"Example","text":"<pre><code># Assuming `crisgi_obj` is an instance with `edata`, `out_dir`, and optionally `groupby` attributes\ngene_sets = {'Pathway1': ['GeneA', 'GeneB'], 'Pathway2': ['GeneC', 'GeneD']}\nresult_df = crisgi_obj.obs_level_CT_rank(gene_sets=gene_sets, prefix='experiment1', min_size=10)\n\n# The results are saved to './&lt;out_dir&gt;/experiment1/prerank_gsva_interaction.csv'\n# The DataFrame `result_df` contains the ranked enrichment scores for each observation.\n</code></pre>"},{"location":"api/pheno_level_CT_rank/","title":"pheno_level_CT_rank","text":""},{"location":"api/pheno_level_CT_rank/#function","title":"Function","text":"<pre><code>crisgi_obj.pheno_level_CT_rank(\n    ref_group,\n    target_group,\n    sortby='pvals_adj',\n    n_top_interactions=None,\n    gene_sets=[\n        'KEGG_2021_Human',\n        'GO_Molecular_Function_2023',\n        'GO_Cellular_Component_2023',\n        'GO_Biological_Process_2023',\n        'MSigDB_Hallmark_2020'\n    ],\n    prefix='test',\n    min_size=5,\n    max_size=1000,\n    permutation_num=1000,\n    seed=0,\n)\n</code></pre> <p>Performs gene set enrichment analysis (GSEA) on ranked gene interactions between a reference group and a comparison group, using multiple gene set libraries. The function ranks genes based on their adjusted p-values or another specified metric, aggregates scores for each gene, and runs GSEA using the <code>gseapy</code> package. Results are saved to disk and stored as an attribute for further analysis.</p>"},{"location":"api/pheno_level_CT_rank/#parameters","title":"Parameters","text":"Name Type Description <code>ref_group</code> <code>str</code> Reference group name for comparison. <code>target_group</code> <code>str</code> Comparison group name. <code>sortby</code> <code>str</code> Column name to sort interactions by (default: <code>'pvals_adj'</code>). <code>n_top_interactions</code> <code>int or None</code> Number of top interactions to include (default: all). <code>gene_sets</code> <code>list of str</code> List of gene set libraries to use for enrichment analysis. <code>prefix</code> <code>str</code> Prefix for output directory and files. <code>min_size</code> <code>int</code> Minimum size of gene sets to include in analysis. <code>max_size</code> <code>int</code> Maximum size of gene sets to include in analysis. <code>permutation_num</code> <code>int</code> Number of permutations for GSEA. <code>seed</code> <code>int</code> Random seed for reproducibility."},{"location":"api/pheno_level_CT_rank/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/pheno_level_CT_rank/#returns","title":"Returns","text":"<p>This function does not return a value. It saves GSEA results and ranked gene data to disk and sets an attribute for further access.</p>"},{"location":"api/pheno_level_CT_rank/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>self.gp_res</code>: Stores the GSEA results object for further analysis.</li> </ul>"},{"location":"api/pheno_level_CT_rank/#example","title":"Example","text":"<pre><code># Assume `obj` is an instance of the class containing pheno_level_CT_rank\n\nobj.pheno_level_CT_rank(\n    ref_group='Control',\n    target_group='Treatment',\n    sortby='pvals_adj',\n    n_top_interactions=100,\n    gene_sets=[\n        'KEGG_2021_Human',\n        'GO_Biological_Process_2023'\n    ],\n    prefix='experiment1',\n    min_size=10,\n    max_size=500,\n    permutation_num=2000,\n    seed=42\n)\n\n# After execution, results are saved in the specified output directory,\n# and the GSEA results are accessible via obj.gp_res.\n</code></pre>"},{"location":"api/pheno_level_accumulated_top_n_ORA/","title":"pheno level accumulated top n ORA","text":""},{"location":"api/pheno_level_accumulated_top_n_ORA/#function","title":"Function","text":"<pre><code>crisgi_obj.pheno_level_accumulated_top_n_ORA(\n    target_group, \n    n_top_interactions=None, \n    n_space=10, \n    method='prod', \n    test_type='TER', \n    gene_sets=[\n        'KEGG_2021_Human',\n        'GO_Molecular_Function_2023',\n        'GO_Cellular_Component_2023',\n        'GO_Biological_Process_2023',\n        'MSigDB_Hallmark_2020'\n    ],\n    background=None, \n    organism='human', \n    plot=True,\n)\n</code></pre> <p>Performs an accumulated over-representation analysis (ORA) for the top-N interactions at the phenotype level. This function iteratively evaluates enrichment for increasing numbers of top interactions, aggregates the results, and saves the enrichment statistics to a CSV file. The results are also stored in the object's attributes for further analysis.</p>"},{"location":"api/pheno_level_accumulated_top_n_ORA/#parameters","title":"Parameters","text":"Name Type Description <code>target_group</code> str The group or phenotype to analyze. <code>n_top_interactions</code> int, optional The maximum number of top interactions to consider. If <code>None</code>, uses all available interactions. <code>n_space</code> int, optional Step size for the number of top interactions to include in each enrichment analysis. Default is <code>10</code>. <code>method</code> str, optional Correlation or interaction method used to select interactions. Default is <code>'prod'</code>. <code>test_type</code> str, optional Type of statistical test applied (e.g., <code>'TER'</code>). Default is <code>'TER'</code>. <code>gene_sets</code> list of str List of gene set databases to use for enrichment analysis. <code>background</code> list or None Background gene set for enrichment. If <code>None</code>, uses default background. <code>organism</code> str, optional Organism name for gene set enrichment (e.g., <code>'human'</code>). Default is <code>'human'</code>. <code>plot</code> bool, optional Whether to generate plots for the enrichment results. Default is <code>True</code>."},{"location":"api/pheno_level_accumulated_top_n_ORA/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/pheno_level_accumulated_top_n_ORA/#returns","title":"Returns","text":"<p>This function does not return a value. It saves the enrichment results as a CSV file and updates the object's attributes with the enrichment results and dataframes.</p>"},{"location":"api/pheno_level_accumulated_top_n_ORA/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>self.edata.uns[f'{method}_{self.groupby}_{target_group}_{test_type}_enrich_res']</code>:     Dictionary mapping top-N values to enrichment results.</li> <li><code>self.edata.uns[f'{method}_{self.groupby}_{target_group}_{test_type}_enrich_df']</code>:     DataFrame containing concatenated enrichment results for all top-N values.</li> </ul>"},{"location":"api/pheno_level_accumulated_top_n_ORA/#example","title":"Example","text":"<pre><code># Assume `obj` is an instance of the class containing this method\n\n# Perform accumulated ORA for the 'disease' group using default parameters\nobj.pheno_level_accumulated_top_n_ORA(target_group='disease')\n\n# Specify custom parameters, such as using only the top 50 interactions and a different gene set\nobj.pheno_level_accumulated_top_n_ORA(\n    target_group='tissue',\n    n_top_interactions=50,\n    n_space=5,\n    method='prod',\n    test_type='TER',\n    gene_sets=['KEGG_2021_Human'],\n    organism='human',\n    plot=False\n)\n\n# After execution, results are saved to a CSV file and stored in:\n# obj.edata.uns['prod_&lt;groupby&gt;_disease_TER_enrich_res']\n# obj.edata.uns['prod_&lt;groupby&gt;_disease_TER_enrich_df']\n</code></pre>"},{"location":"api/pl.interaction_score_line/","title":"pl.interaction_score_line","text":""},{"location":"api/pl.interaction_score_line/#function","title":"Function","text":"<pre><code>pl.interaction_score_line(\n    crisgi_obj,\n    target_group=None,\n    method=\"prod\",\n    test_type=\"TER\",\n    interactions=None,\n    unit_header=\"subject\",\n    title=\"\",\n    out_prefix=\"test\",\n    ax=None,\n)\n</code></pre> <p>Generates and plots a line chart of interaction scores (entropy-based) for a specified group or all groups within a CRISGI object. The function computes average interaction scores over time for selected interactions and visualizes them using seaborn's lineplot, supporting customization of grouping, statistical method, and output options.</p>"},{"location":"api/pl.interaction_score_line/#parameters","title":"Parameters","text":"Name Type Description crisgi_obj CRISGI The CRISGI object containing experimental data and metadata. target_group str or None Specific group to plot. If <code>None</code>, iterates over all groups in <code>crisgi_obj.groups</code>. method str Statistical method for score calculation (e.g., <code>'prod'</code>). test_type str Type of test or interaction (e.g., <code>'TER'</code>). interactions list or None List of interaction names to include. If <code>None</code>, uses all interactions for the group and method. unit_header str or None Column name in <code>obs</code> to use as units for repeated measures (e.g., <code>'subject'</code>). title str Custom title prefix for the plot. out_prefix str Prefix for output file name if saving the plot. ax matplotlib.axes.Axes or None Matplotlib Axes object to plot on. If <code>None</code>, creates a new figure."},{"location":"api/pl.interaction_score_line/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/pl.interaction_score_line/#returns","title":"Returns","text":"<p>This function does not return a value. It generates and displays (and optionally saves) a line plot of average interaction scores over time for the specified group(s).</p>"},{"location":"api/pl.interaction_score_line/#attributes-set","title":"Attributes Set","text":"<ul> <li>No attributes are set by this function. The function operates on the provided <code>crisgi_obj</code> and does not modify its state.</li> </ul>"},{"location":"api/pl.interaction_score_line/#example","title":"Example","text":"<pre><code>import crisgi.plotting_crisgi_time as pl\n\n# Assume crisgi_obj is a pre-loaded CRISGI object with required data\n# Plot with specific interactions and custom unit_header\nselected_interactions = ['geneA_geneB', 'geneC_geneD']\npl.interaction_score_line(\n    crisgi_obj,\n    target_group='Symptomatic',\n    method='prod',\n    test_type='TER',\n    interactions=selected_interactions,\n    unit_header='subject_id',\n    title='Selected Interactions ',\n    out_prefix='selected_interactions'\n)\n</code></pre>"},{"location":"api/pl.pheno_level_accumulated_top_n_ORA/","title":"pl.pheno_level_accumulated_top_n_ORA","text":""},{"location":"api/pl.pheno_level_accumulated_top_n_ORA/#function","title":"Function","text":"<pre><code>pl.pheno_level_accumulated_top_n_ORA(\n    target_group,\n    method=\"prod\",\n    test_type=\"TER\",\n    p_adjust=True,\n    p_cutoff=0.05,\n    n_top_pathway=10,\n    n_top_interactions=500,\n    piority_term=None,\n    eval_para='top_n_ratio',\n    dataset_name=None\n)\n</code></pre> <p>Performs pathway enrichment analysis at the phenotype level using the top-N accumulation strategy. This function evaluates pathway enrichment results across multiple top-N gene sets, ranks pathways based on a specified evaluation parameter, and visualizes the results as a heatmap. It supports prioritization of specific pathways and flexible evaluation metrics.</p>"},{"location":"api/pl.pheno_level_accumulated_top_n_ORA/#parameters","title":"Parameters","text":"Name Type Description <code>target_group</code> str Target group for enrichment analysis (e.g., phenotype or cluster name). <code>method</code> str, optional Correlation method used for analysis. Default is <code>\"prod\"</code>. <code>test_type</code> str, optional Type of statistical test. Default is <code>\"TER\"</code>. <code>p_adjust</code> bool, optional Whether to use adjusted p-values for filtering. Default is <code>True</code>. <code>p_cutoff</code> float, optional P-value cutoff for significance filtering. Default is <code>0.05</code>. <code>n_top_pathway</code> int, optional Number of top pathways to display in the heatmap. Default is <code>10</code>. <code>n_top_interactions</code> int, optional Maximum number of top interactions (gene sets) to consider. Default is <code>500</code>. <code>piority_term</code> list or None, optional List of pathway terms to prioritize or <code>None</code> for no prioritization. Default is <code>None</code>. <code>eval_para</code> str, optional Evaluation parameter for ranking pathways. Options: <code>'top_n_ratio'</code>, <code>'overlap_ratio'</code>, <code>'P-value'</code>, <code>'Adjusted P-value'</code>, <code>'Odds Ratio'</code>, <code>'Combined Score'</code>, <code>'-logP'</code>. Default is <code>'top_n_ratio'</code>. <code>dataset_name</code> str or None, optional Name of the dataset for labeling outputs. Default is <code>None</code>."},{"location":"api/pl.pheno_level_accumulated_top_n_ORA/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/pl.pheno_level_accumulated_top_n_ORA/#returns","title":"Returns","text":"<ul> <li>Saves a heatmap plot of the top-N pathway enrichment results to the output directory.</li> <li>Displays the heatmap in the current matplotlib session.</li> <li>Prints the output file path.</li> </ul>"},{"location":"api/pl.pheno_level_accumulated_top_n_ORA/#attributes-set","title":"Attributes Set","text":"<ul> <li>No new attributes are set on the CRISGI object by this function.</li> </ul>"},{"location":"api/pl.pheno_level_accumulated_top_n_ORA/#example","title":"Example","text":"<pre><code># Assume crisgi_obj is an instance of CRISGI with enrichment results computed\n\n# Perform top-N pathway enrichment analysis for the 'Tumor' group\ncrisgi_obj.pheno_level_accumulated_top_n_ORA(\n    target_group='Tumor',\n    method='prod',\n    test_type='TER',\n    p_adjust=True,\n    p_cutoff=0.01,\n    n_top_pathway=15,\n    n_top_interactions=300,\n    piority_term=['Apoptosis', 'Cell Cycle'],\n    eval_para='overlap_ratio',\n    dataset_name='CancerStudy'\n)\n\n# The function will save and display a heatmap of the top 15 pathways\n# ranked by overlap ratio for the 'Tumor' group, highlighting prioritized terms.\n</code></pre>"},{"location":"api/save/","title":"save","text":""},{"location":"api/save/#function","title":"Function","text":"<pre><code>crisgi_obj.save()\n</code></pre> <p>This function serializes the CRISGI object and saves it as a pickle file <code>*.pk</code> in the output directory, using the dataset name as part of the filename.</p>"},{"location":"api/save/#parameters","title":"Parameters","text":"Name Type Description self object The instance of the CRISGI class to be saved."},{"location":"api/save/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/save/#returns","title":"Returns","text":"<p>This function does not return any value. It performs the side effect of saving the object to a file.</p>"},{"location":"api/save/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>out_dir</code>: The directory where the pickle file will be saved.</li> <li><code>dataset</code>: The name of the dataset, used in the filename.</li> </ul>"},{"location":"api/save/#example","title":"Example","text":"<pre><code># Assume crisgi_obj is an instance of the CRISGI class\ncrisgi_obj.out_dir = '/path/to/output'\ncrisgi_obj.dataset = 'my_dataset'\n\n# Save the CRISGI object to a pickle file\ncrisgi_obj.save()\n\n# Output:\n# [Output] CRISGI object has benn saved to:\n# /path/to/output/my_dataset_crisgi_obj.pk\n</code></pre> <p>This example demonstrates how to set the output directory and dataset name before calling <code>save()</code> to persist the CRISGI object.</p>"},{"location":"api/survival_analysis/","title":"survival_analysis","text":""},{"location":"api/survival_analysis/#function","title":"Function","text":"<pre><code>crisgi_obj.survival_analysis(\n    ref_group,\n    target_group,\n    interactions=None,\n    groupbys=[],\n    survival_types=['os', 'pfs'],\n    time_unit='time',\n    test_type='TER',\n    method='prod',\n    title=''\n)\n</code></pre> <p>Performs survival analysis using Kaplan-Meier estimators and log-rank tests for specified groups and survival types. This method generates survival plots and statistical comparisons between groups, saving the resulting figures and printing output messages.</p>"},{"location":"api/survival_analysis/#parameters","title":"Parameters","text":"Name Type Description ref_group str Reference group name used for entropy calculation. target_group str Comparison group name for analysis. interactions list or None List of interaction features to include; if None, uses default from <code>edata.uns</code>. groupbys list Additional columns in <code>obs</code> to group data by, in addition to score group. survival_types list List of survival types to analyze (e.g., <code>['os', 'pfs']</code>). time_unit str Label for the time axis in plots (e.g., <code>'months'</code>, <code>'days'</code>). test_type str Type of statistical test to use (default: <code>'TER'</code>). method str Method for entropy calculation (default: <code>'prod'</code>). title str Title prefix for the generated plots."},{"location":"api/survival_analysis/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/survival_analysis/#returns","title":"Returns","text":"<p>This function does not return a value. It generates and saves survival plots for each specified survival type and grouping, and prints the output file paths.</p>"},{"location":"api/survival_analysis/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>edata.obs['score']</code>: Stores the computed score for each observation.</li> <li><code>edata.obs['score_group']</code>: Stores the assigned score group for each observation.</li> </ul>"},{"location":"api/survival_analysis/#example","title":"Example","text":"<pre><code># Assume `crisgi` is an instance of the CRISGI class with loaded data\n\n# Perform survival analysis comparing 'control' and 'treatment' groups\ncrisgi.survival_analysis(\n    ref_group='control',\n    target_group='treatment',\n    interactions=['geneA', 'geneB'],\n    groupbys=['batch'],\n    survival_types=['os'],\n    time_unit='months',\n    test_type='DER',\n    method='prod',\n    title='Survival Analysis Example'\n)\n</code></pre> <p>This example compares the overall survival (<code>'os'</code>) between 'control' and 'treatment' groups, considering interactions for 'geneA' and 'geneB', and grouping by 'batch'. The resulting survival plot is saved to the output directory, and the file path is printed.</p>"},{"location":"api/test_DER/","title":"test_DER","text":""},{"location":"api/test_DER/#function","title":"Function","text":"<pre><code>crisgi_obj.test_DER(\n    groupby,\n    target_group=None,\n    test_method=\"wilcoxon\",\n    method='prod',\n)\n</code></pre> <p>Performs differential entropy ranking (DER) analysis on the provided AnnData object, comparing groups defined by the <code>groupby</code> column. The function computes group-wise entropy, applies statistical tests (e.g., Wilcoxon), and aggregates results for downstream analysis.</p>"},{"location":"api/test_DER/#parameters","title":"Parameters","text":"Name Type Description groupby str The column in <code>adata.obs</code> used to define groups for comparison. target_group str, optional Specific group to compare against the reference group. If <code>None</code>, all groups are compared. test_method str, optional Statistical test method to use (default: <code>\"wilcoxon\"</code>). method str, optional Entropy calculation method (default: <code>'prod'</code>)."},{"location":"api/test_DER/#return-type","title":"Return type","text":"<p><code>pandas.DataFrame</code></p>"},{"location":"api/test_DER/#returns","title":"Returns","text":"<p>A DataFrame containing differential entropy ranking results for each group comparison. Columns include gene names, reference and target groups, method used, and mean entropy values for each group.</p>"},{"location":"api/test_DER/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>self.groups</code>: List of unique group names from <code>groupby</code>.</li> <li><code>self.groupby</code>: The groupby column name.</li> <li><code>edata.uns[f'{method}_rank_genes_groups_{ref_group}_{target_group}']</code>: Stores ranking results for each group comparison.</li> <li><code>edata.uns['rank_genes_groups_df']</code>: Stores the concatenated DataFrame of all results.</li> </ul>"},{"location":"api/test_DER/#example","title":"Example","text":"<pre><code># Assume `obj` is an instance with an AnnData object as `obj.adata`\n# Compare groups in the 'cell_type' column using the default Wilcoxon test and 'prod' method\nresult_df = obj.test_DER(groupby='cell_type')\n\n# To compare a specific group, e.g., 'B_cell', against all others:\nresult_df = obj.test_DER(groupby='cell_type', target_group='B_cell')\n\n# Access the results\nprint(result_df.head())\n\n# Access attributes set by the function\nprint(obj.groups)  # List of group names\nprint(obj.groupby) # The groupby column name\n</code></pre>"},{"location":"api/test_TER/","title":"test_TER","text":""},{"location":"api/test_TER/#function","title":"Function","text":"<pre><code>crisgi_obj.test_TER(\n    target_group=None, \n    p_cutoff=0.05, \n    method=\"prod\", \n    groups=None\n)\n</code></pre> <p>Identifies Trend Expressed Interactions (TER) for each group in the dataset. This function evaluates interactions based on trend analysis and statistical significance, saving the results and statistics for downstream analysis.</p>"},{"location":"api/test_TER/#parameters","title":"Parameters","text":"Name Type Description target_group str or None Specific group to analyze. If <code>None</code>, all groups in <code>groups</code> are processed. p_cutoff float P-value cutoff for statistical significance (default: <code>0.05</code>). method str Method used for interaction analysis (e.g., <code>'prod'</code>). groups list or None List of groups to analyze. If <code>None</code>, uses <code>self.groups</code>."},{"location":"api/test_TER/#return-type","title":"Return type","text":"<p><code>None</code></p>"},{"location":"api/test_TER/#returns","title":"Returns","text":"<p>This function does not return a value. It saves TER results and statistics to the <code>edata.uns</code> attribute and outputs CSV files with TER statistics for each group.</p>"},{"location":"api/test_TER/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>edata.uns[f'{method}_{self.groupby}_{target_group}_TER']</code>: List of filtered interactions identified as TER.</li> <li><code>edata.uns[f'{method}_{self.groupby}_{target_group}_TER_df']</code>: DataFrame containing detailed TER statistics for each interaction.</li> </ul>"},{"location":"api/test_TER/#example","title":"Example","text":"<pre><code># Assume `crisgi` is an instance of the CRISGI class, already initialized with data.\n\n# Run TER analysis for all groups using the default method and p-value cutoff\ncrisgi.test_TER()\n\n# Run TER analysis for a specific group with a custom p-value cutoff\ncrisgi.test_TER(target_group='GroupA', p_cutoff=0.01)\n\n# Run TER analysis for a custom list of groups and a different method\ncustom_groups = ['GroupA', 'GroupB']\ncrisgi.test_TER(groups=custom_groups, method='sum')\n</code></pre> <p>After execution, TER results and statistics are saved in the <code>edata.uns</code> attribute and as CSV files in the specified output directory.</p>"},{"location":"api/test_val_trend_entropy/","title":"test_val_trend_entropy","text":""},{"location":"api/test_val_trend_entropy/#function","title":"Function","text":"<pre><code>crisgi.test_val_trend_entropy(\n    interactions,\n    method=\"prod\",\n    p_cutoff=0.05,\n    out_prefix=\"./test\",\n)\n</code></pre> <p>Performs trend and zero-trend statistical tests on a list of interactions using entropy-based values, identifying validation trend expressed interactions (TERs) based on significance thresholds.</p>"},{"location":"api/test_val_trend_entropy/#parameters","title":"Parameters","text":"Name Type Description interactions list of str List of interaction names to be tested. method str, optional Correlation method used for entropy calculation. Default is <code>'prod'</code>. p_cutoff float, optional Significance threshold for trend and zero-trend tests. Default is <code>0.05</code>. out_prefix str, optional Prefix for the output CSV file containing TER statistics. Default is <code>'./test'</code>."},{"location":"api/test_val_trend_entropy/#return-type","title":"Return type","text":"<p><code>list of str</code></p>"},{"location":"api/test_val_trend_entropy/#returns","title":"Returns","text":"<p>A list of interaction names that are identified as validation trend expressed interactions (TERs) based on the specified statistical criteria.</p>"},{"location":"api/test_val_trend_entropy/#attributes-set","title":"Attributes Set","text":"<ul> <li>Saves a CSV file named <code>{out_prefix}_TER.csv</code> containing the trend and zero-trend test results for all tested interactions.</li> </ul>"},{"location":"api/test_val_trend_entropy/#example","title":"Example","text":"<pre><code># Assume `crisgi` is an instance of the CRISGI class and edata is already set up.\n\ninteractions = ['geneA', 'geneB', 'geneC']\ncandidates = crisgi.test_val_trend_entropy(\n    interactions=interactions,\n    method='prod',\n    p_cutoff=0.01,\n    out_prefix='./results/val_trend'\n)\n\nprint(\"TER candidates:\", candidates)\n# Output CSV will be saved as './results/val_trend_TER.csv'\n</code></pre>"},{"location":"api/train_predict/","title":"train &amp; predict","text":""},{"location":"api/train_predict/#function","title":"Function","text":""},{"location":"api/train_predict/#train","title":"train","text":"<p>Trains the selected model using the provided training data loader. The training process adapts based on the model type: for logistic regression, the number of epochs is managed internally, while for other models, the number of epochs can be specified.</p>"},{"location":"api/train_predict/#predict","title":"predict","text":"<p>Generates predictions using the trained model on the provided data loader. This function abstracts the prediction process for different model types, ensuring a consistent interface.</p>"},{"location":"api/train_predict/#parameters","title":"Parameters","text":"Name Type Description train_loader DataLoader The data loader containing the training dataset. epochs int, optional Number of training epochs (used for non-logistic models). Default is <code>10</code>. data_loader DataLoader The data loader containing the data for which predictions are to be made."},{"location":"api/train_predict/#return-type","title":"Return type","text":"<ul> <li><code>train</code>: Depends on the underlying model's <code>train</code> method. Typically returns training metrics or status.</li> <li><code>predict</code>: Model-specific prediction output (e.g., numpy array, tensor, or list of predictions).</li> </ul>"},{"location":"api/train_predict/#returns","title":"Returns","text":"<ul> <li>train: Returns the result of the model's training process, which may include training loss, accuracy, or a status indicator.</li> <li>predict: Returns the predictions generated by the model for the input data.</li> </ul>"},{"location":"api/train_predict/#attributes-set","title":"Attributes Set","text":"<ul> <li><code>self.model_type</code>: Sets the type of model being used (e.g., \"cnn\", \"simple_cnn\", \"logistic\").</li> <li><code>self.model</code>: The instantiated model object corresponding to the selected type.</li> <li><code>self.device</code>: The device (e.g., 'cpu' or 'cuda') on which the model will operate.</li> </ul>"},{"location":"api/train_predict/#example","title":"Example","text":"<pre><code>from crisgi import CRISGI\nimport pickle\nfrom torchvision import transforms\nfrom torch.utils.data import DataLoader\nfrom src.cnn.CNNModel import CNNModel\nfrom src.simplecnn.SimpleCNNModel import SimpleCNNModel\nfrom src.logistic.LogisticModel import LogisticModel\nfrom src.util import ImageDataset\nimport src.plotting_sniee_time as pl\n\ncrisgi_obj = pickle.load(open(\"data/GSE30550_H3N2_crisgi_obj.pk\", 'rb'))\n\n# Set up the training data loader\ntransform = transforms.Compose([\n    transforms.Resize((224, 224)),\n    transforms.ToTensor()\n])\n\ndataset = ImageDataset(\n    image_dir='./out1',\n    label_csv='./out1/labels.csv',\n    transform=transform,\n    return_label=True\n)\n\nloader = DataLoader(dataset, batch_size=16, shuffle=True)\n\n# Set the model type and initialize the model\n# 3L-CNN\ncrisgi_obj.set_model_type(model_type='cnn',ae_path=\"data/model/3L-CNN/GSE30550_H3N2_ae_model.pth\", mlp_path=\"data/model/3L-CNN/GSE30550_H3N2_mlp_model.pth\")\n# 1L-CNN\ncrisgi_obj.set_model_type(model_type='simple_cnn')\n# Logistic Regression\ncrisgi_obj.set_model_type(model_type='logistic', model_path=\"data/model/logistic/GSE30550_H3N2_log_model.pth\",device = 'cpu')\n\n# Train the model\ncrisgi_obj.train(loader, epochs=20)\n\n# Generate predictions using the trained model\npredictions = crisgi_obj.predict(loader)\n\n# Print the predictions\nprint(predictions)\n</code></pre>"},{"location":"tutorial/gse30550/","title":"Influenza A Bulk RNA-seq Data","text":"<pre><code>from crisgi import CRISGITime\nimport pandas as pd\nimport anndata as ad\nfrom scipy.sparse import csr_matrix\n</code></pre> <pre><code># Load raw data and meta data\nadata = ad.read_h5ad(\"./data/GSE30550_raw.adata\")\nmeta_data = pd.read_csv(\"./data/GSE30550_meta.csv\", index_col=0)\n\n# There is a default background network in the raw data, which is not needed for the analysis\ndel adata.varm[\"bg_net\"]\n\n# Preprocess the data\nadata.layers[\"log1p\"] = adata.X\nadata.obs[\"symptom\"] = adata.obs[\"clinic_pheno:ch1\"]\nadata.obs[\"subject\"] = adata.obs[\"person\"]\n# The baseline time point samples are regarded as the reference samples\nadata.obs[\"type\"] = adata.obs[\"time\"].apply(\n    lambda x: \"Ref\" if x == \"Baseline\" else \"Test\"\n)\nadata.obs[\"timepoint\"] = adata.obs.time\n# Extract the time number from the timepoint column\nadata.obs[\"time\"] = adata.obs.timepoint.apply(\n    lambda x: -24 if x == \"Baseline\" else x.replace(\"Hour \", \" \")\n).astype(int)\n# Combine the subject and time columns to create a unique identifier for each sample\nadata.obs[\"test\"] = (\n    adata.obs[\"subject\"].astype(str) + \" \" + adata.obs[\"time\"].astype(str)\n)\nadata.obs[\"clinical_symptoms\"] = meta_data.loc[\n    adata.obs.index, \"clinical_symptoms\"\n].values\n\n# Remove the original columns that are no longer needed\ndel adata.obs[\"clinic_pheno:ch1\"]\n</code></pre> <p>We can save the processed data in a hdf5 file for later use.</p> <pre><code>adata.write_h5ad(\"./data/GSE30550_H3N2.h5ad\")\n</code></pre> <p>Or load the preprocessed data from the hdf5 file.</p> <pre><code>adata = ad.read_h5ad(\"./data/GSE30550_H3N2.h5ad\")\n</code></pre> <pre><code># Define the calculating interaction methods (list format)\ninteraction_methods = [\"prod\"]\n# Create CRISGITime object\ncrisgi_obj = CRISGITime(\n    adata=adata,\n    interaction_methods=interaction_methods,\n    n_hvg=5000,\n    organism=\"human\",\n    n_threads=1,\n    dataset=\"GSE30550_H3N2\",\n    class_type=\"time\",\n    out_dir=\"./out\",\n)\n</code></pre> <pre>\n<code>input gene 5000\nload bg_net by looping bg_net.\noutput interactions after bg_net 15753\nThe number of edge for bg_net is 15753.\nModel type set to 'cnn'.\n</code>\n</pre> <pre><code>ref_obs = adata.obs[adata.obs.type == \"Ref\"].index.to_list()\ntest_obss = [[x] for x in adata.obs.index.to_list()]\n</code></pre> <pre><code># Set the groupby column\ngroupby = \"symptom\"\n\n# Calculate the entropy\ncrisgi_obj.calculate_entropy(\n    ref_obs=ref_obs,\n    test_obss=test_obss,\n    groupby=groupby,\n    ref_time=\"Ref\",\n    layer=\"log1p\",\n)\n</code></pre> <pre>\n<code>reference observations 16\ntest population 268\nInit edata with obs 268 and interaction 15753\n---Calculating the entropy for reference group\n---Calculating the entropy for test population 0, observations 1\n---Calculating the entropy for test population 1, observations 1\n---Calculating the entropy for test population 2, observations 1\n---Calculating the entropy for test population 3, observations 1\n...\n---Calculating the entropy for test population 265, observations 1\n---Calculating the entropy for test population 266, observations 1\n---Calculating the entropy for test population 267, observations 1\n</code>\n</pre> <pre><code>n_top_interactions = 100\ntest_type = \"TER\"\ntarget_group = \"Symptomatic\"\n</code></pre> <pre><code>crisgi_obj.test_DER(\n    groupby=\"symptom\",\n    target_group=target_group,\n)\ncrisgi_obj.get_DER(\n    target_group=target_group,\n    n_top_interactions=n_top_interactions,\n    p_adjust=True,\n    p_cutoff=0.05,\n    fc_cutoff=1,\n    sortby=\"pvals_adj\",\n)\ncrisgi_obj.test_TER(target_group=target_group)\n</code></pre> <pre>\n<code>[Output] The differential expressed interaction (DER) 100 statistics are saved to:\n./out/prod_symptom_Symptomatic_DER.csv\nprod_symptom_Symptomatic DER 100 TER 99\n[Output] The trend expressed interaction (TER) statistics are saved to:\n./out/prod_symptom_Symptomatic_TER.csv\n</code>\n</pre> <pre><code># Import required libraries\nimport crisgi.plotting_crisgi_time as pl\n\ninteraction_method = \"prod\"\n# Plot general DER/TER results\npl.interaction_score_line(\n    crisgi_obj,\n    target_group=target_group,\n    method=interaction_method,\n    test_type=test_type,\n    unit_header=None,\n)\n\n# Generate interaction score matrix for each subject\npl.get_interaction_score(\n    crisgi_obj,\n    target_group=target_group,\n    groupby=groupby,\n    method=interaction_method,\n    test_type=test_type,\n    subject_header=\"subject\",\n    out_dir=None,\n)\n\n# Generate interaction score images\npl.generate_interaction_score_images(\n    folder_path=crisgi_obj.out_dir,\n    output_path=crisgi_obj.out_dir,\n    rep_n=1,\n    robust=True,\n    scale=False,\n)\n</code></pre> <pre>\n<code>prod_symptom_Symptomatic_TER\nNone\n</code>\n</pre> <pre>\n<code>subjects 17 times 16\n[Output] The subject 1 prod symptom Symptomatic TER99 entropy scores are saved to:\n./out/1_prod_symptom_Symptomatic_TER99_interaction_score.csv\n[Output] The subject 2 prod symptom Symptomatic TER99 entropy scores are saved to:\n./out/2_prod_symptom_Symptomatic_TER99_interaction_score.csv\n[Output] The subject 3 prod symptom Symptomatic TER99 entropy scores are saved to:\n./out/3_prod_symptom_Symptomatic_TER99_interaction_score.csv\n...\n[Output] The subject 16 prod symptom Symptomatic TER99 entropy scores are saved to:\n./out/16_prod_symptom_Symptomatic_TER99_interaction_score.csv\n[Output] The subject 17 prod symptom Symptomatic TER99 entropy scores are saved to:\n./out/17_prod_symptom_Symptomatic_TER99_interaction_score.csv\n[Output] The interaction score image is saved to:\n./out\\10_prod_symptom_Symptomatic_TER99_interaction_score_rep0.png\n[Output] The interaction score image is saved to:\n./out\\11_prod_symptom_Symptomatic_TER99_interaction_score_rep0.png\n[Output] The interaction score image is saved to:\n./out\\12_prod_symptom_Symptomatic_TER99_interaction_score_rep0.png\n...\n./out\\8_prod_symptom_Symptomatic_TER99_interaction_score_rep0.png\n[Output] The interaction score image is saved to:\n./out\\9_prod_symptom_Symptomatic_TER99_interaction_score_rep0.png\n</code>\n</pre> <pre><code>crisgi_obj.detect_startpoint(symptom_types = [\"Symptomatic\"])\nprint(crisgi_obj.edata.obs.CT_time)\n</code></pre> <pre>\n<code>test\n1 -24     21.0\n1 0       21.0\n1 5       21.0\n1 12      21.0\n1 21      21.0\n...\n17 77      NaN\n17 84      NaN\n17 93      NaN\n17 101     NaN\n17 108     NaN\nName: CT_time, Length: 268, dtype: float64\n</code>\n</pre> <pre><code># Import required libraries\nimport torch\nimport os\nfrom torchvision import transforms\nfrom torch.utils.data import DataLoader\nfrom crisgi.util import ImageDataset\nimport crisgi.plotting_crisgi_time as pl\n\n# Check if GPU is available and set device\ncrisgi_obj.device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n\n# Transform for image preprocessing\ntransform = transforms.Compose([transforms.Resize((224, 224)), transforms.ToTensor()])\nimage_dir = os.path.join(crisgi_obj.out_dir, \"images\")\nif not os.path.exists(image_dir):\n    os.makedirs(image_dir)\n# Generate interaction score images\npl.plot_interaction_score(\n    crisgi_obj,\n    output_path=image_dir,\n    robust=True,\n    scale=False,\n    rep_n=2,\n    label=True,\n)\n# Create a dataset and dataloader\ndataset = ImageDataset(\n    image_dir=image_dir,\n    label_csv=os.path.join(image_dir, \"labels.csv\"),\n    transform=transform,\n    return_label=True,\n)\nloader = DataLoader(dataset, batch_size=16, shuffle=True)\n</code></pre> <pre>\n<code>[Output] Labels saved to: ./out\\images\\labels.csv\n</code>\n</pre> <pre><code># 3L-CNN model\ncrisgi_obj.set_model_type(\n    model_type=\"cnn\",\n    # ae_path=\"./data/model/3L-CNN/GSE30550_H3N2_ae_model.pth\",\n    # mlp_path=\"./data/model/3L-CNN/GSE30550_H3N2_mlp_model.pth\",\n    device=crisgi_obj.device,\n)\n</code></pre> <pre>\n<code>Model type set to 'cnn'.\n</code>\n</pre> <pre><code># 1L-CNN model\ncrisgi_obj.set_model_type(\n    model_type=\"simple_cnn\",\n    # ae_path=\"./data/model/1L-CNN/GSE30550_H3N2_ae_single_model.pth\",\n    # mlp_path=\"./data/model/1L-CNN/GSE30550_H3N2_mlp_single_model.pth\",\n    device=crisgi_obj.device,\n)\n</code></pre> <pre>\n<code>Model type set to 'simple_cnn'.\n</code>\n</pre> <pre><code># Logistic regression model\ncrisgi_obj.set_model_type(model_type='logistic',\n    # model_path=\"./data/model/logistic/GSE30550_H3N2_log_model.pth\",\n    device = crisgi_obj.device,\n)\n</code></pre> <pre>\n<code>Model type set to 'logistic'.\n</code>\n</pre> <pre><code>crisgi_obj.train(train_loader=loader, epochs=20)\n</code></pre> <pre>\n<code>\nEpoch 1/20\nTotal Train Loss: 3.9969566043685463\nTrain Accuracy: 47.05882352941177%\n\nEpoch 2/20\nTotal Train Loss: 0.5858943539068979\nTrain Accuracy: 64.70588235294117%\n\nEpoch 3/20\nTotal Train Loss: 0.11467249735313303\nTrain Accuracy: 82.3529411764706%\n...\nEpoch 19/20\nTotal Train Loss: 0.010214821873780559\nTrain Accuracy: 97.05882352941177%\n\nEpoch 20/20\nTotal Train Loss: 0.0028154985869632046\nTrain Accuracy: 100.0%\n</code>\n</pre> <pre>\n<code>{'AUROC': 1.0,\n 'AUPRC': 1.0,\n 'Accuracy': 1.0,\n 'Precision': 1.0,\n 'Recall': 1.0,\n 'Sensitivity': 1.0,\n 'Specificity': 1.0,\n 'PPV': 1.0,\n 'NPV': 1.0,\n 'F1_Score': 1.0,\n 'Kappa': 1.0,\n 'Brier_Score': 0.0}</code>\n</pre> <pre><code>predictions = crisgi_obj.predict(loader)\nprint(predictions)\n</code></pre> <pre>\n<code>[0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1]\n</code>\n</pre> <pre><code>torch.save(crisgi_obj.model.ae, \"./data/GSE30550_H3N2_ae_model.pth\") \ntorch.save(crisgi_obj.model.mlp, \"./data/GSE30550_H3N2_mlp_model.pth\")\n</code></pre> <pre><code># The result will be generated in ./{out_dir}/{interaction_method}_cohort_enrich.csv\ncrisgi_obj.cohort_level_top_n_ORA(\n    n_top_interactions=30,\n    method=\"prod\",\n    gene_sets=[\n        \"KEGG_2021_Human\",\n        \"GO_Molecular_Function_2023\",\n        \"GO_Cellular_Component_2023\",\n        \"GO_Biological_Process_2023\",\n        \"MSigDB_Hallmark_2020\",\n    ],\n    background=None,\n    organism=\"human\",\n    plot=True,\n)\n</code></pre> <pre>\n<code>_enrich_for_top_n 30\n[Output] The prod cohort-level enrich statistics are saved to:\n./out/prod_cohort_enrich.csv\n</code>\n</pre> <pre><code># Also, the results can be accessed through the edata object\ncrisgi_obj.edata.uns[f\"{interaction_method}_cohort_enrich_df\"]\n</code></pre> Gene_set Term Overlap P-value Adjusted P-value Old P-value Old Adjusted P-value Odds Ratio Combined Score Genes n_gene top_n top_n_ratio 0 KEGG_2021_Human Vitamin digestion and absorption 2/24 0.000090 0.001447 0 0 181.509091 1690.049095 APOA1;APOB 2 10 0.200000 1 KEGG_2021_Human Fat digestion and absorption 2/43 0.000294 0.002122 0 0 97.302439 791.273330 APOA1;APOB 2 10 0.200000 2 KEGG_2021_Human Cholesterol metabolism 2/50 0.000398 0.002122 0 0 83.083333 650.497584 APOA1;APOB 2 10 0.200000 3 KEGG_2021_Human Complement and coagulation cascades 2/85 0.001146 0.004584 0 0 47.963855 324.786952 A2M;CLU 2 10 0.200000 4 KEGG_2021_Human Lipid and atherosclerosis 2/215 0.007072 0.022629 0 0 18.568075 91.942655 APOA1;APOB 2 10 0.200000 ... ... ... ... ... ... ... ... ... ... ... ... ... ... 1039 MSigDB_Hallmark_2020 Inflammatory Response 1/200 0.303808 0.303808 0 0 2.837760 3.380791 IL1B 1 30 0.033333 1040 MSigDB_Hallmark_2020 Xenobiotic Metabolism 1/200 0.303808 0.303808 0 0 2.837760 3.380791 CNDP2 1 30 0.033333 1041 MSigDB_Hallmark_2020 Oxidative Phosphorylation 1/200 0.303808 0.303808 0 0 2.837760 3.380791 ALDH6A1 1 30 0.033333 1042 MSigDB_Hallmark_2020 heme Metabolism 1/200 0.303808 0.303808 0 0 2.837760 3.380791 ALDH6A1 1 30 0.033333 1043 MSigDB_Hallmark_2020 KRAS Signaling Up 1/200 0.303808 0.303808 0 0 2.837760 3.380791 IL1B 1 30 0.033333 <p>2264 rows \u00d7 13 columns</p> <pre><code>crisgi_obj.n_threads = 1\ninteraction_method = \"prod\"\n\n# The result will be generated in {interaction_method}_{groupby}_{target_group}_{test_type}_enrich.csv in out_dir\ncrisgi_obj.pheno_level_accumulated_top_n_ORA(\n    target_group=target_group,\n    n_top_interactions=30,\n    n_space=10,\n    method=interaction_method,\n    test_type=test_type,\n)\n\n# Plot the phenotype-level accumulated top n ORA results\npl.pheno_level_accumulated_top_n_ORA(\n    crisgi_obj,\n    target_group=target_group,\n    p_adjust=True,\n    p_cutoff=0.05,\n    n_top_interactions=30,\n    method=interaction_method,\n    test_type=test_type,\n)\n</code></pre> <pre>\n<code>_enrich_for_top_n 10\n_enrich_for_top_n 20\n_enrich_for_top_n 30\n[Output] The prod symptom Symptomatic TER enrich statistics are saved to:\n./out/prod_symptom_Symptomatic_TER_enrich.csv\n[Output] The prod symptom Symptomatic TER GO_Biological_Process_2023 top_n_ratio top_n enrichment is saved to:\n./out/prod_symptom_Symptomatic_TER_GO_Biological_Process_2023_top_n_ratio_enrich_top_n.png\n</code>\n</pre> <pre>\n<code>[Output] The prod symptom Symptomatic TER GO_Molecular_Function_2023 top_n_ratio top_n enrichment is saved to:\n./out/prod_symptom_Symptomatic_TER_GO_Molecular_Function_2023_top_n_ratio_enrich_top_n.png\n</code>\n</pre> <pre>\n<code>[Output] The prod symptom Symptomatic TER KEGG_2021_Human top_n_ratio top_n enrichment is saved to:\n./out/prod_symptom_Symptomatic_TER_KEGG_2021_Human_top_n_ratio_enrich_top_n.png\n</code>\n</pre> <pre>\n<code>[Output] The prod symptom Symptomatic TER MSigDB_Hallmark_2020 top_n_ratio top_n enrichment is saved to:\n./out/prod_symptom_Symptomatic_TER_MSigDB_Hallmark_2020_top_n_ratio_enrich_top_n.png\n</code>\n</pre> <pre><code># Also, the results can be accessed through the edata object\ncrisgi_obj.edata.uns[f\"{interaction_method}_{groupby}_{target_group}_{test_type}_enrich_df\"]\n</code></pre> Gene_set Term Overlap P-value Adjusted P-value Old P-value Old Adjusted P-value Odds Ratio Combined Score Genes n_gene top_n top_n_ratio 0 KEGG_2021_Human Cytosolic DNA-sensing pathway 5/63 5.164674e-10 2.001242e-08 0 0 190.881226 4081.805842 CXCL10;AIM2;TBK1;IRF7;CASP1 5 10 0.500000 1 KEGG_2021_Human Influenza A 6/172 1.051221e-09 2.001242e-08 0 0 89.548193 1851.257888 CXCL10;TBK1;MX1;IRF7;CASP1;CCL2 6 10 0.600000 2 KEGG_2021_Human NOD-like receptor signaling pathway 6/181 1.429458e-09 2.001242e-08 0 0 84.904286 1729.158160 AIM2;TBK1;IFI16;IRF7;CASP1;CCL2 6 10 0.600000 3 KEGG_2021_Human Coronavirus disease 6/232 6.345181e-09 6.662440e-08 0 0 65.575221 1237.769693 CXCL10;TBK1;MX1;CASP1;CCL2;ISG15 6 10 0.600000 4 KEGG_2021_Human RIG-I-like receptor signaling pathway 4/70 1.341046e-07 1.126479e-06 0 0 120.727273 1910.466285 CXCL10;TBK1;IRF7;ISG15 4 10 0.400000 ... ... ... ... ... ... ... ... ... ... ... ... ... ... 971 MSigDB_Hallmark_2020 Fatty Acid Metabolism 1/158 2.365362e-01 2.896478e-01 0 0 3.823393 5.512010 UBE2L6 1 30 0.033333 972 MSigDB_Hallmark_2020 heme Metabolism 1/200 2.896478e-01 2.896478e-01 0 0 3.010050 3.729722 ACKR1 1 30 0.033333 973 MSigDB_Hallmark_2020 mTORC1 Signaling 1/200 2.896478e-01 2.896478e-01 0 0 3.010050 3.729722 TBK1 1 30 0.033333 974 MSigDB_Hallmark_2020 E2F Targets 1/200 2.896478e-01 2.896478e-01 0 0 3.010050 3.729722 TP53 1 30 0.033333 975 MSigDB_Hallmark_2020 Epithelial Mesenchymal Transition 1/200 2.896478e-01 2.896478e-01 0 0 3.010050 3.729722 CXCL1 1 30 0.033333 <p>2062 rows * 13 columns</p> <pre><code># Set the reference and target groups for the CT rank test\nref_group = \"Asymptomatic\"\ntarget_group = \"Symptomatic\"\n# Results will be saved in the folder ./out_dir/{prefix}_{ref_group}_{target_group}\ncrisgi_obj.pheno_level_CT_rank(\n    ref_group=ref_group,\n    target_group=target_group,\n    n_top_interactions=n_top_interactions,\n    sortby=\"pvals_adj\",\n    gene_sets=[\n        \"KEGG_2021_Human\",\n        \"GO_Molecular_Function_2023\",\n        \"GO_Cellular_Component_2023\",\n        \"GO_Biological_Process_2023\",\n        \"MSigDB_Hallmark_2020\",\n    ],\n    prefix=\"pheno_level_CT_rank\",\n    min_size=5,\n    max_size=1000,\n    permutation_num=1000,\n    seed=0,\n)\n</code></pre> <pre>\n<code>2025-05-06 03:45:44,853 [WARNING] Duplicated values found in preranked stats: 84.09% of genes\nThe order of those genes will be arbitrary, which may produce unexpected results.\n2025-05-06 03:45:44,854 [INFO] Parsing data files for GSEA.............................\n2025-05-06 03:45:44,855 [INFO] Enrichr library gene sets already downloaded in: C:\\Users\\LVCS\\.cache/gseapy, use local file\n2025-05-06 03:45:44,859 [INFO] Enrichr library gene sets already downloaded in: C:\\Users\\LVCS\\.cache/gseapy, use local file\n2025-05-06 03:45:44,865 [INFO] Enrichr library gene sets already downloaded in: C:\\Users\\LVCS\\.cache/gseapy, use local file\n2025-05-06 03:45:44,871 [INFO] Enrichr library gene sets already downloaded in: C:\\Users\\LVCS\\.cache/gseapy, use local file\n2025-05-06 03:45:44,894 [INFO] Enrichr library gene sets already downloaded in: C:\\Users\\LVCS\\.cache/gseapy, use local file\n2025-05-06 03:45:44,918 [INFO] 7154 gene_sets have been filtered out when max_size=1000 and min_size=5\n2025-05-06 03:45:44,919 [INFO] 0244 gene_sets used for further statistical testing.....\n2025-05-06 03:45:44,919 [INFO] Start to run GSEA...Might take a while..................\n2025-05-06 03:45:50,005 [INFO] Start to generate gseapy reports, and produce figures...\n2025-05-06 03:45:50,006 [INFO] Congratulations. GSEApy runs successfully................\n\n</code>\n</pre> <pre><code># The results can be accessed through the gp_res object\ncrisgi_obj.gp_res.results\n</code></pre> <pre>\n<code>{'KEGG_2021_Human__Platelet activation': {'name': 'prerank',\n  'es': -0.28823529411764703,\n  'nes': -0.8502622255406148,\n  'pval': 0.6423357664233577,\n  'fdr': 1.0,\n  'fwerp': 1.0,\n  'tag %': '6/6',\n  'gene %': '72.73%',\n  'lead_genes': 'COL1A2;GNAI2;AKT2;GNAQ;PIK3R1;F2',\n  'matched_genes': 'F2;PIK3R1;GNAQ;AKT2;GNAI2;COL1A2',\n  'hits': [49, 61, 70, 115, 155, 169],\n  'RES': [-0.0058823529411764705,\n   -0.011764705882352941,\n   -0.01764705882352941,\n   -0.023529411764705882,\n   -0.029411764705882353,\n   -0.017543859649122806,\n</code>\n</pre> <pre><code># Parameters for the observation-level CT rank test\nenrich_dataset = \"GSE30550_H3N2\"\ninteraction_method = \"prod\"\n\n# Set the \ninteractions = crisgi_obj.edata.uns[\n    f\"{interaction_method}_{groupby}_{target_group}_{test_type}\"\n][0:n_top_interactions]\ngene_sets = {f\"{enrich_dataset} {test_type}{n_top_interactions}\": interactions}\n\n# The results will be generated in ./out_dir/{prefix} folder\ncrisgi_obj.obs_level_CT_rank(\n    gene_sets=gene_sets,\n    prefix=\"obs_level_CT_rank\",\n    min_size=5,\n)\n</code></pre> <pre><code># The results can be accessed through the gp_es object\ncrisgi_obj.gp_es.results\n</code></pre> <pre>\n<code>{'1 -24': {'GSE30550_H3N2 TER100': {'name': '1 -24',\n   'es': -0.3363774857096424,\n   'nes': 0.0,\n   'pval': 0.0,\n   'fdr': 0.0,\n   'fwerp': 0.0,\n   'tag %': '',\n   'gene %': '',\n   'lead_genes': '',\n   'matched_genes': '',\n   'hits': [],\n   'RES': []}},\n '1 0': {'GSE30550_H3N2 TER100': {'name': '1 0',\n</code>\n</pre>"},{"location":"tutorial/gse30550/#influenza-a-bulk-rna-seq-data","title":"Influenza A Bulk RNA-seq Data","text":"<p>There is a tutorial for the CRISGITime package using the GSE30550 dataset, which contains bulk RNA-seq data from patients infected with the H3N2 influenza virus. The dataset includes samples collected at different time points and clinical symptoms.</p>"},{"location":"tutorial/gse30550/#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/compbioclub/CRISGI.git@main\n</code></pre>"},{"location":"tutorial/gse30550/#importing-required-libraries","title":"Importing Required Libraries","text":""},{"location":"tutorial/gse30550/#loading-data-preprocessing","title":"Loading Data &amp; Preprocessing","text":"<p>First, we need to load the raw data and preprocess it.</p> <p>The basic information like the number of samples, genes, and time points can be obtained from the raw data.</p> <p>The meta_data contains the sample information, including the time points and detailed clinical symptoms.</p>"},{"location":"tutorial/gse30550/#creating-crisgitime-object","title":"Creating CRISGITIME Object","text":"<p>Next, we can create a CRISGITIME object using the preprocessed data. This object will be used for further analysis.</p>"},{"location":"tutorial/gse30550/#reference-and-test-populations","title":"Reference and Test Populations","text":"<p>We filter the samples to create reference and test populations.</p> <p>The baseline samples are used as the reference population <code>ref_obs</code>, while the test population <code>test_obss</code> consists of samples from different time points (all samples).</p>"},{"location":"tutorial/gse30550/#calculating-entropy","title":"Calculating Entropy","text":"<p>Parameter <code>groupby</code> is used to specify the grouping of the test samples.</p> <p>In <code>crisgi_obj.adata.obs</code>, we can find the <code>symptom</code> column, which contains the label (<code>Symptomatic</code>/<code>Asymptomatic</code>) for each sample.</p> <p>Filling the proper parameters in <code>crisgi_obj.calculate_entropy()</code>, we can calculate the entropy for the test population.</p>"},{"location":"tutorial/gse30550/#setting-derter-parameters","title":"Setting DER/TER Parameters","text":"<p>Here we set the parameters for the DER/TER analysis.</p> <p><code>n_top_interactions</code> is the number of top interactions to be considered. If set to <code>None</code>, all interactions will be considered.</p> <p><code>test_type</code> is used to specify the type of test to be performed. The options are <code>DER</code> (differentially expressed interactions) and <code>TER</code> (trend-expressed interactions). <code>DER</code> and <code>TER</code> are two types of interactions that can be adopted in finding key interactions in the CRISGITime package. <code>TER</code> is a subset of <code>DER</code>, and it is used to find the interactions that are differentially expressed in a specific trend (up or down) across time points.</p> <p><code>target_group</code> is used to specify the target group for the analysis, which should be an element in the <code>groupby</code> column. In this case, we are interested in the <code>Symptomatic</code> group, which contains samples from patients with symptoms.</p>"},{"location":"tutorial/gse30550/#calulating-der-and-ter","title":"Calulating DER and TER","text":"<p>There are three steps to calculate DER and TER. First, we use <code>test_DER</code> to calculate DER score for every interaction. Then, we use <code>get_DER</code> with specific parameters to get the DER results. Finally, based on the DER results, we use <code>test_TER</code> to get the TER results.</p> <p>The results of DER and TER will be saved in the <code>crisgi_obj</code> object and output as CSV files.</p>"},{"location":"tutorial/gse30550/#derter-results-output","title":"DER/TER Results Output","text":"<p>Here we can use <code>pl.interaction_score_line</code> to get a general overview of the DER/TER results for the <code>target_group</code>. This function will plot the average interaction scores for the <code>target_group</code> and <code>ref_group</code>, allowing us to visualize the differences between the symptomatic and asymptomatic groups.</p> <p>The <code>pl.get_interaction_score</code> and <code>pl.generate_interaction_score_images</code> functions can generate every sample's DER/TER result, and it will be output as a CSV file and a heatmap.</p> <p>The <code>method</code> parameter should be an element in the <code>interaction_methods</code> list.</p>"},{"location":"tutorial/gse30550/#startpoint-detection","title":"Startpoint Detection","text":"<p>The <code>startpoint_detection</code> function is used to detect the start points (early-warning signals) in the time series data. The results will be saved in the <code>crisgi_obj.edata.obs.CT_time</code>.</p>"},{"location":"tutorial/gse30550/#training-and-predicting-with-crisgitime","title":"Training and Predicting with CRISGITime","text":"<p>We can use the <code>train</code> &amp; <code>predict</code> functions to train and predict the CRISGITime model by using the TER/DER results as the feature matrix.</p> <p>The <code>train</code> function will train the model using the training data, and the <code>predict</code> function will use the trained/loaded model to predict the test data.</p>"},{"location":"tutorial/gse30550/#choosingloading-the-model","title":"Choosing/Loading the Model","text":"<p>There are three different models that can be used in <code>set_model_type</code>: <code>cnn</code> (3L-CNN), <code>simple_cnn</code> (1L-CNN), and <code>logistic</code> (logistic regression).</p> <p>The <code>model_type</code> parameter is used to specify the model type. You can load the model from a file in <code>ae_path</code> and <code>mlp_path</code> if you want to use a pre-trained model, or train a new model with <code>None</code>.</p>"},{"location":"tutorial/gse30550/#training-the-model","title":"Training the Model","text":""},{"location":"tutorial/gse30550/#predicting-the-model","title":"Predicting the Model","text":""},{"location":"tutorial/gse30550/#saving-the-model","title":"Saving the Model","text":""},{"location":"tutorial/gse30550/#enrichment-analysis","title":"Enrichment Analysis","text":"<p>We have four different levels of enrichment analysis for you to choose: <code>cohort_level_top_n_ORA</code>, <code>Phenotype-level Accumulated Top n ORA</code>, <code>Phenotype-level CT-rank enrichment</code>, and <code>Observation-level CT-rank enrichment</code>.</p>"},{"location":"tutorial/gse30550/#cohort-level-top-n-ora","title":"Cohort-level Top n ORA","text":"<p>To capture CT interactions that are consistently strong across a cohort, we sum up the CRISGI scores for each interaction across all observations. The top-n interactions from this aggregate ranking were then used for over-representation analysis (ORA), identifying pathways enriched among globally dominant CT interactions across the population.</p>"},{"location":"tutorial/gse30550/#phenotype-level-accumulated-top-n-ora","title":"Phenotype-level Accumulated Top n ORA","text":"<p>We can perform ORA on incremental top-n CT interactions, ranked by CRISGI z-scores from differential testing, using a predefined step size. For each significantly enriched pathway, we can compute a normalized Top Ratio (<code>nTopRatio</code>), defined as the fraction of pathway-associated CT interactions within each top-n subset. </p> <p>Pathways are ranked by cumulative <code>nTopRatio</code> across all increments to highlight consistently enriched pathways across high-ranking CTs. </p>"},{"location":"tutorial/gse30550/#phenotype-level-ct-rank-enrichment","title":"Phenotype-level CT-rank enrichment","text":"<p>Using Kolmogorov-Smirnov (KS)-like statistic, we can compute enrichment scores over the full ranking of CT genes based on their phenotype-specific CRISGI z-scores derived from differential test (phenotype A vs. phenotype B). This reveals pathways with directional fluctuation or stability trends across the ranked list.</p> <p>Positive enrichment scores indicate pathway in phenotype A exhibits elevated fluctuations (i.e., more prominent CT signals); negative scores imply relative stability compared to phenotype B.</p>"},{"location":"tutorial/gse30550/#observation-level-ct-rank-enrichment","title":"Observation-level CT-rank enrichment","text":"<p>We extend the KS-like enrichment analysis to the observation level using CRISGI scores specific to each observation.</p> <p>A positive enrichment score reflects pathway actively fluctuating in that observation, while a negative score indicates stability.</p>"}]}